import type { BlogPost } from './types';

export const blogPosts: BlogPost[] = [
  {
    id: 'first-hackathon',
    title: 'ハッカソンを振り返る1/3（UMP-JUST）',
    summary: '初めて参加したハッカソンについて今更ですが振り返ります．',
    content: `# はじめに

去年は初めてハッカソンに参加したのですが，その後も他のハッカソンに参加し，合計3回出場しました．

振り返りをしていなかったので，参加の経緯や得られたことについてまとめておきます．

1つの記事では1つのハッカソンについてまとめます．３部構成です．

# TL;DR;
- UMP-JUSTハッカソンの参加記録をまとめました
- 技術賞とcotomi賞を受賞することができました
- チームメンバーとさらに仲良くなりました

[公式による大会記録](https://ump-just.i.u-tokyo.ac.jp/2024/10011337051610/)

[開発したサービス 【にほん GO UP APP】](https://nihon-go-up-app.vercel.app/)

[発表スライド](https://drive.google.com/file/d/1P33v6AeTH96daZJ3wcWP9QqZngSPy6jZ/view?usp=drive_link)

[Github](https://github.com/Omusubi0123/nihon-go-up-app)


# ハッカソンとは

ハッカソンとは，主にComputer Science系の学生が集まり，短期間でソフトウェアサービスを開発するイベントです．

基本的な流れ

**1．テーマ発表：**
  - 主催者から作成するサービスのテーマが発表されます．参加者はテーマに沿ったサービスを開発します．

**2．チーム編成：**
  - 参加者は3〜5人のチームを編成し，指定された開発期間でサービスを開発します．
  - チームメンバーの中でも役割分担（サービスを開発するエンジニア，サービスのプレゼンを行うプレゼンテーターなど）するのが一般的です．
  - ソフトウェア開発の場合，さらに細かくフロントエンド（Webサイト開発）・バックエンド（API・DB開発）・インフラ（デプロイ等）の担当で分けるのが一般的です．

**3．開発期間：**
  - 多くは1日〜2日で開催され，アイデアだしからサービス開発，最終発表まで行います．
  - 開発期間が1ヶ月ほど与えられるハッカソンもあります．
  - 2日間のハッカソンの場合，1日目の夜は徹夜に近い状態で開発することになります（深夜4時くらいから自分の限界を超え始める）．

**4．発表・審査：**
  - 開発したサービスを発表します．
  - ピッチ形式，2分~10分の発表時間であることが多いです．
  - 開発背景→課題→解決策→サービス内容→デモ，の流れが一般的です．
  - どれだけ良いサービスを開発してもプレゼンがうまくいかないと審査員には伝わらないので，スライド資料・プレゼンにも力を入れる必要があります．


# UMP-JUSTハッカソン
僕が初めて参加したハッカソンです．
2024年9月7日，8日の2日間で開催されました．

東京大学大学院情報理工学系研究科の一組織「UMP-JUST」が主催のハッカソンで，当時所属していた学科の教授が宣伝しているのを見て知りました．

ハッカソンのテーマは「生成AI」．（特にLLM）をテーマにしたものでした．

2023年以降はLLMの爆発的な普及によって，生成AIをテーマにしたハッカソンが非常に多いです．


# 参加背景
高専時代や大学2年次はハッカソンに一度も参加したことがなく，ハッカソンは未知の世界でした．

そんな中，その年の3月に大学編入同期の友人があるハッカソンで優勝し海外研修に行くのを知り，ハッカソンに興味を持ち始めました．

しかし，当時の僕はソフトウェア開発について全く知識がなく，個人開発の経験もありませんでした．できることと言えばpythonやLLMを使ったアルゴリズム開発くらい・・・．
（友人の仕事の関係でハッカソン前に少しソフトウェア開発に携わることになったのですが，それはまた別の機会に）

ただ，このハッカソンは条件があまりに良く，貴重な機会でした．
参加学生が学内に限られていて，電子情報工学科の3, 4学生 or 情報理工の院生のみだと思われる（昨年は参加チームが10チーム程度）．
さらに，優勝賞金が30万円と大会の規模に対して非常に高額．．．
対外的に開催しているハッカソンでは，優勝賞金が10万前後，賞金なしの場合もある，参加チームは30チーム以上であることが多い．
それを考えるとこのハッカソンの条件は別格です．

お金に目が眩んだ僕は参加することにしました．

# メンバー探し
参加することに決めた次は，チームメンバーを探します．

声をかけるチームメンバーは参加を決めた瞬間から決めていました．
大学編入同期でインターン先も同じだった2人に声をかけました．
2人とは1年以上の付き合いがあり，実力に対して絶対の信頼をおいていたので，この2人以外にはいないなと考えていました．

強い仲間を引き入れて自分の実力の無さを補う作戦です．

幸い，2人とも参加を快諾してくれました．チームメンバー探しはこれにて終了です．

# 事前準備
ハッカソンは２日間のみの開催なので，アイデア出しはある程度事前に行っておくのが得策です（当日になってアイデア出しから始めると，実質的な開発時間は徹夜でやっても10時間弱になる）．

メンバーと事前にmeetingを2回ほど行い，アイデアだしを行いました．
メンバーの1人は先ほど述べた優勝経験のあるメンバーだったので，アイデア出しや当日のノウハウは彼に教えてもらいました．

meetingを通してメンバー2人とさらに仲良くなれました．
アイデア出しも楽しい時間になりました．

開発するサービスの案を2つまで絞り込み，本番に臨みました．

# 本番
## 1日目
会場は東大の弥生キャンパスにありました．
普段通っている本郷キャンパスと隣接しているキャンパスですが，初めて入った場所でした．

朝早くに起きて大学に向かい，何だか新鮮な気分の状態で会場に向かいました．

参加チームは10チームでした．
学部3年の同級生が2チーム，学部4年のチームが1チーム(?)，即席チームが1, 2チーム，残りが修士チーム・博士チームでした．

会場に入った瞬間は，ハッカソンへの参加が初めてなのもあり，かなり緊張しました．
ですが強強のチームメンバーが一緒だったので少し経ったら緊張は解消されました．
小中学生時代に参加していたピアノの発表会ではずっと緊張していたので，仲間がいることに心強さを感じました．

1日目は前半がアイデアソン（アイデアを出し合う）で，後半からプロトタイプ開発が始まりました．
アイデアソンでは終始わいわいでしたが，開発が始まったらどのチームも忙しく開発してました．

昼休憩時間に開発するサービスを決定し，午後は開発を頑張りました．
僕はbackend・LLMを使ったアルゴリズムの開発，友人Aはfrontend・インフラの開発，友人Bはリーダー兼ビジネスモデル調査・プレゼンを担当することにしました．
役割分担が綺麗に決まり，事前にMVP（Minimul Viable Product）を話し合っていたこともあり，開発はスムーズに行えました．

初日の開発は順調に終わりました．

ここからが徹夜作業です．

帰宅後，zoomで開発の方針・明日の方針を決め，爆速開発に入ります．
僕は睡魔に勝てず深夜4時ごろには寝たのですが，友人Aは徹夜で頑張ってくれました（本当に感謝）．
深夜テンションでの開発は楽しいです．zoomを繋いでおしゃべりしながら開発すｒのでさらに仲良くなります．

## 2日目
一番の難関，朝の起床を乗り越えました．
無事会場に辿り着きます．

午前中は開発だったので，ずっと残りの開発をしていました．
計画通りの時間にデプロイ段階に入りましたが，若干バグが残った状態で開発時間が終了してしまいました．
ギリギリまで全集中して取り組んでくれた友人Aには大感謝です．

若干の心残りはありましたが，作ったサービスには相当な自信があったので自信を持って発表に臨みました．

友人Bがスライドを作ってくれました．ビジネスモデル提案から開発したプロダクト・デモ紹介まで素晴らしいスライドで，大感謝でした．
発表も完璧で，感謝でいっぱいです．

### プロダクトデモ動画

実際に開発したサービスのデモ動画です：

<video src="/blog/first-hackathon/demo.MP4" controls></video>

## 結果
全チームのプレゼンが終わり，ドキドキの状態で結果発表を待っていました．
開発したプロダクトの出来，プレゼンともに両方良い感触を持ちましたが，審査はどうなるかわからないのでかなり緊張しました．

審査の結果，技術賞とcotomi賞を受賞することができました．
非常に嬉しかったです．

![受賞の様子](/blog/first-hackathon/prize.jpg)

大会が終わった後は打ち上げで本郷三丁目近くの韓国焼肉屋に行きました．
非常に美味しかったです．

### 打ち上げの様子

<video src="/blog/first-hackathon/uchiage.MOV" controls muted></video>

メンバーと雑談も色々できてさらに仲良くなりました．

# 感想
ハッカソンは開発期間が短くて大変だけど，期間が短いが故に技術も急成長すると感じました．

同じチームで参加してくれた友人に大感謝．

ハッカソン楽しかったです．
    `,
    date: '2025-08-26',
    tags: ['ハッカソン'],
    thumbnail: '/blog/first-hackathon/demo.MP4'
  },
  {
    id: 'develop-blog',
    title: 'ブログを開設しました',
    summary: 'ポートフォリオサイトにブログ機能を追加しました．気ままに発信していきます．',
    content: `# ブログを開設しました

ポートフォリオサイトにブログ機能を追加しました．

## このブログについて

このブログでは以下のような内容を投稿していく予定です：

- **技術学習の記録**: 新しく学んだ技術やツールについて
- **プロジェクトの進捗報告**: 現在取り組んでいるプロジェクトの状況
- **開発での気づき**: 開発中に発見した小技やハマったポイント
- **活動記録**: ハッカソンやインターン，学会発表などの活動記録
- **その他の雑記**: 日々の思考や発見について

## 技術スタック

このブログシステムは以下の技術で構築されています：

- **React + TypeScript**: フロントエンド開発
- **Tailwind CSS**: スタイリング
- **React Markdown**: Markdown記事の表示
- **React Router**: ページルーティング

## 今後の予定
- どのくらいの頻度になるかは分かりませんが，気ままに更新していく予定です．
- 気が向いたら読んでください．`,
    date: '2025-08-25',
    tags: ['お知らせ'],
    thumbnail: '/portfolio.png'
  },
//   {
//     id: 'react-performance-optimization',
//     title: 'React パフォーマンス最適化のベストプラクティス',
//     summary: 'Reactアプリケーションのパフォーマンスを向上させるための実践的なテクニックをまとめました。',
//     content: `# React パフォーマンス最適化のベストプラクティス

// Reactアプリケーションのパフォーマンスを向上させるための実践的なテクニックをまとめました。

// ## 1. useMemo と useCallback の適切な使用

// ### useMemo
// 計算コストの高い処理をメモ化：

// \`\`\`typescript
// const ExpensiveComponent = ({ data }: { data: any[] }) => {
//   const expensiveValue = useMemo(() => {
//     return data.reduce((acc, item) => acc + item.value, 0);
//   }, [data]);

//   return <div>{expensiveValue}</div>;
// };
// \`\`\`

// ### useCallback
// 関数の再生成を防ぐ：

// \`\`\`typescript
// const ParentComponent = () => {
//   const [count, setCount] = useState(0);
  
//   const handleClick = useCallback(() => {
//     setCount(prev => prev + 1);
//   }, []);
  
//   return <ChildComponent onClick={handleClick} />;
// };
// \`\`\`

// ## 2. React.memo の活用

// 不要な再レンダリングを防ぐ：

// \`\`\`typescript
// const ChildComponent = React.memo(({ name, onClick }: Props) => {
//   return (
//     <button onClick={onClick}>
//       {name}
//     </button>
//   );
// });
// \`\`\`

// ## 3. 仮想化 (Virtualization)

// 大量のリストを効率的に表示：

// \`\`\`typescript
// import { FixedSizeList as List } from 'react-window';

// const VirtualizedList = ({ items }: { items: any[] }) => (
//   <List
//     height={600}
//     itemCount={items.length}
//     itemSize={50}
//   >
//     {({ index, style }) => (
//       <div style={style}>
//         {items[index].name}
//       </div>
//     )}
//   </List>
// );
// \`\`\`

// ## 4. Code Splitting

// 動的インポートでバンドルサイズを削減：

// \`\`\`typescript
// const LazyComponent = lazy(() => import('./LazyComponent'));

// const App = () => (
//   <Suspense fallback={<div>Loading...</div>}>
//     <LazyComponent />
//   </Suspense>
// );
// \`\`\`

// ## まとめ

// これらのテクニックを適切に組み合わせることで、Reactアプリケーションのパフォーマンスを大幅に向上させることができます。

// 重要なのは、すべてを最適化するのではなく、**本当にボトルネックになっている部分を特定して対策する**ことです。`,
//     date: '2024-01-10',
//     tags: ['React', 'パフォーマンス', 'JavaScript', 'TypeScript'],
//   },
//   {
//     id: 'machine-learning-fundamentals',
//     title: '機械学習の基礎：線形回帰から始めよう',
//     summary: '機械学習の入門として線形回帰を数式と実装の両面から解説します。数学的な背景も含めて理解を深めましょう。',
//     content: `# 機械学習の基礎：線形回帰から始めよう

// 機械学習の入門として、最もシンプルかつ重要な手法である**線形回帰**について学んでいきましょう。

// ## 線形回帰とは

// 線形回帰は、入力変数 $x$ と出力変数 $y$ の間の線形関係をモデル化する手法です。

// ### 数学的表現

// 単純線形回帰の場合、以下の式で表されます：

// $$y = wx + b + \\epsilon$$

// ここで：
// - $w$: 重み（傾き）
// - $b$: バイアス（切片）
// - $\\epsilon$: 誤差項

// ## 損失関数

// 線形回帰では、**平均二乗誤差（MSE）**を損失関数として使用します：

// $$L(w, b) = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - (wx_i + b))^2$$

// この損失関数を最小化することで、最適なパラメータ $w$ と $b$ を求めます。

// ## 勾配降下法

// 損失関数を最小化するために、勾配降下法を使用します。

// パラメータの更新式：

// $$w := w - \\alpha \\frac{\\partial L}{\\partial w}$$
// $$b := b - \\alpha \\frac{\\partial L}{\\partial b}$$

// ここで $\\alpha$ は学習率です。

// ### 勾配の計算

// 偏微分を計算すると：

// $$\\frac{\\partial L}{\\partial w} = \\frac{2}{n} \\sum_{i=1}^{n} (wx_i + b - y_i) x_i$$

// $$\\frac{\\partial L}{\\partial b} = \\frac{2}{n} \\sum_{i=1}^{n} (wx_i + b - y_i)$$

// ## 実装例

// Pythonでの実装例：

// \`\`\`python
// import numpy as np
// import matplotlib.pyplot as plt

// class LinearRegression:
//     def __init__(self, learning_rate=0.01, n_iterations=1000):
//         self.learning_rate = learning_rate
//         self.n_iterations = n_iterations
    
//     def fit(self, X, y):
//         # パラメータの初期化
//         self.weight = 0
//         self.bias = 0
        
//         n_samples = X.shape[0]
        
//         # 勾配降下法
//         for i in range(self.n_iterations):
//             # 予測値の計算
//             y_pred = self.weight * X + self.bias
            
//             # 損失の計算
//             cost = (1 / n_samples) * np.sum((y - y_pred) ** 2)
            
//             # 勾配の計算
//             dw = (2 / n_samples) * np.sum(X * (y_pred - y))
//             db = (2 / n_samples) * np.sum(y_pred - y)
            
//             # パラメータの更新
//             self.weight -= self.learning_rate * dw
//             self.bias -= self.learning_rate * db
    
//     def predict(self, X):
//         return self.weight * X + self.bias

// # 使用例
// X = np.random.randn(100, 1)
// y = 2 * X.flatten() + 1 + 0.1 * np.random.randn(100)

// model = LinearRegression(learning_rate=0.01, n_iterations=1000)
// model.fit(X.flatten(), y)

// print(f"学習された重み: {model.weight:.2f}")
// print(f"学習されたバイアス: {model.bias:.2f}")
// \`\`\`

// ## 多変量線形回帰

// 複数の特徴量がある場合は、以下のように拡張できます：

// $$y = w_1x_1 + w_2x_2 + ... + w_nx_n + b$$

// ベクトル形式で表現すると：

// $$y = \\mathbf{w}^T\\mathbf{x} + b$$

// ## 正規方程式

// 勾配降下法以外にも、正規方程式を使って解析的に最適解を求めることができます：

// $$\\mathbf{w} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y}$$

// ## まとめ

// 線形回帰は機械学習の基礎となる重要な手法です。シンプルながらも多くの実問題に適用でき、他の複雑な手法を理解するための土台となります。

// 次回は**ロジスティック回帰**について学んでいきましょう！`,
//     date: '2024-01-12',
//     tags: ['機械学習', '数学', 'Python', 'データサイエンス']
//   }
];

export const getBlogPost = (id: string): BlogPost | undefined => {
  return blogPosts.find(post => post.id === id);
};

export const getBlogPostMetadata = () => {
  return blogPosts.map(({ content, ...metadata }) => metadata);
};
